name: CI/CD Pipeline with Security Features

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch: # Allow manual triggering

env:
  IMAGE_NAME: myapplication

jobs:
  secret-scan:
    name: Detect Secrets
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Get full history for versioning
      
      - name: Install Gitleaks
        run: |
          wget https://github.com/zricethezav/gitleaks/releases/download/v8.16.3/gitleaks_8.16.3_linux_x64.tar.gz
          tar -xzf gitleaks_8.16.3_linux_x64.tar.gz
          sudo mv gitleaks /usr/local/bin/
      
      - name: Create allowlist file for CI/CD patterns
        run: |
          cat > .gitleaks.toml << 'EOF'
          [allowlist]
          paths = [
            '''\.github/workflows/.*'''
          ]
          
          regexes = [
            '''secrets\.GITHUB_TOKEN''',
            '''uses: docker/login-action''',
            '''password: \$\{\{ secrets\.'''
          ]
          EOF
      
      - name: Scan for secrets
        run: gitleaks detect --source . --config .gitleaks.toml
      
      - name: Setup pre-commit hook for developers
        run: |
          mkdir -p .git/hooks
          cat > setup-git-hooks.sh << 'EOF'
          #!/bin/bash
          
          # Create pre-commit hook
          cat > .git/hooks/pre-commit << 'HOOK'
          #!/bin/bash
          
          # Download and install gitleaks if not installed
          if ! command -v gitleaks &> /dev/null; then
            echo "Installing gitleaks..."
            TEMP_DIR=$(mktemp -d)
            cd $TEMP_DIR
            curl -sSfL https://github.com/zricethezav/gitleaks/releases/download/v8.16.3/gitleaks_8.16.3_linux_x64.tar.gz | tar -xz
            sudo mv gitleaks /usr/local/bin/
            cd -
            rm -rf $TEMP_DIR
          fi
          
          # Create allowlist for workflow files
          cat > .gitleaks.toml << 'CONFIG'
          [allowlist]
          paths = [
            '''\.github/workflows/.*'''
          ]
          
          regexes = [
            '''secrets\.GITHUB_TOKEN''',
            '''uses: docker/login-action''',
            '''password: \$\{\{ secrets\.'''
          ]
          CONFIG
          
          # Run gitleaks
          echo "Scanning for secrets..."
          if ! gitleaks detect --source . --staged --config .gitleaks.toml; then
            echo "Secret detected! Commit aborted."
            exit 1
          fi
          
          exit 0
          HOOK
          
          # Make hook executable
          chmod +x .git/hooks/pre-commit
          echo "Git hooks installed successfully!"
          EOF
          
          chmod +x setup-git-hooks.sh
          ./setup-git-hooks.sh
          
          # Add instruction for developers in README
          echo "## Security Setup
          
          To set up local security scanning, run:
          
          \`\`\`
          ./setup-git-hooks.sh
          \`\`\`
          
          This will install a pre-commit hook that scans for secrets.
          " >> README.md

  dependency-scan:
    name: Scan Dependencies
    needs: secret-scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: "temurin"
          java-version: "17"
          cache: "maven"
      
      - name: Run OWASP Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        id: dependency-check
        with:
          project: 'MyApp'
          path: '.'
          format: 'HTML'
          out: 'reports' 
          args: >
            --failOnCVSS 7
            --enableRetired
      
      - name: Upload dependency check report
        uses: actions/upload-artifact@v3
        with:
          name: dependency-check-report
          path: ${{ github.workspace }}/reports
      
      - name: Check Maven dependencies
        run: |
          mvn org.cyclonedx:cyclonedx-maven-plugin:makeAggregateBom
          echo "Checking for critical vulnerabilities..."
          mvn dependency:analyze-only

  dockerfile-scan:
    name: Scan Dockerfile
    needs: secret-scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Create multi-stage Dockerfile
        run: |
          # Creating Dockerfile with optimization techniques
          cat > Dockerfile << 'EOF'

          FROM maven:3.9-amazoncorretto-17 AS build
          WORKDIR /app

          # Copy only pom.xml first to leverage Docker cache layers
          COPY pom.xml .
          RUN mvn dependency:go-offline

          # Copy source and build
          COPY src ./src
          RUN mvn clean package -DskipTests

          # Try to detect if this is a Spring Boot app with layering support
          # This creates a conditional build pipeline that works with both
          # regular Java apps and Spring Boot apps with layertools
          RUN mkdir -p extracted && \
              if jar -tf target/*.jar | grep -q "BOOT-INF/layers.idx"; then \
                echo "Spring Boot layered JAR detected, extracting layers..."; \
                java -Djarmode=layertools -jar target/*.jar extract --destination extracted; \
              else \
                echo "Regular JAR detected, using simple copy..."; \
                mkdir -p extracted/application; \
                cp target/*.jar extracted/application/; \
              fi

          FROM eclipse-temurin:17-jre-alpine
          WORKDIR /app

          # Add labels for better maintainability
          LABEL org.opencontainers.image.source=https://github.com/$GITHUB_REPOSITORY
          LABEL org.opencontainers.image.description="Optimized Java application container"

          # Security: Create non-root user for running the application
          RUN addgroup --system javauser && adduser --system --ingroup javauser javauser

          # Try to copy layers if available, fall back to regular JAR if not
          # This supports both Spring Boot layered apps and regular Java apps
          COPY --from=build --chown=javauser:javauser /app/extracted/ ./

          # Set appropriate permissions
          RUN chmod -R u=rX,g=rX /app
          USER javauser

          # Alpine optimization: Remove unnecessary files to keep image small
          # Container ready configuration
          ENV JAVA_OPTS="-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0"

          EXPOSE 8080

          # Dynamic entrypoint that works for both Spring Boot and standard Java apps
          ENTRYPOINT ["sh", "-c", "if [ -f 'org/springframework/boot/loader/JarLauncher.class' ]; then java $JAVA_OPTS org.springframework.boot.loader.JarLauncher; elif [ -d 'application' ]; then java $JAVA_OPTS -jar application/*.jar; else java $JAVA_OPTS -jar *.jar; fi"]
          EOF
      
      - name: Install Hadolint
        run: |
          wget -O hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
          chmod +x hadolint
          sudo mv hadolint /usr/local/bin/
      
      - name: Run Hadolint
        run: hadolint Dockerfile --failure-threshold error
      
      - name: Install Trivy
        run: |
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | gpg --dearmor | sudo tee /usr/share/keyrings/trivy.gpg > /dev/null
          echo "deb [signed-by=/usr/share/keyrings/trivy.gpg] https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy
      
      - name: Scan Dockerfile with Trivy
        run: |
          trivy config --severity HIGH,CRITICAL --exit-code 1 ./Dockerfile

  build-and-deploy:
    name: Build and Sign
    needs: [dependency-scan, dockerfile-scan]
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed for version commit
      packages: write # Needed for ghcr.io push
      id-token: write # Needed for keyless signing
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Get full history for versioning

      - name: Cleanup workspace and Docker
        run: |
          echo "Cleaning up workspace..."
          git clean -fdx

          echo "Pruning Docker resources..."
          docker system prune -af --volumes || true

          echo "Removing any previous build artifacts..."
          rm -rf target/ || true

          echo "Cleanup complete."

      - name: Bump Version
        id: bump
        uses: nnichols/maven-version-bump-action@v3
        # with:
        # github-token: ${{ secrets.github_token }}

      - name: Print Version
        run: "echo 'New Version: ${{steps.bump.outputs.version}}'"

      - name: Extract Git metadata for tagging
        id: git-metadata
        shell: bash
        run: |
          SHA_SHORT=$(git rev-parse --short HEAD)
          DATE=$(date +'%Y%m%d')
          BRANCH=${GITHUB_REF#refs/heads/}

          echo "sha_short=${SHA_SHORT}" >> "$GITHUB_OUTPUT"
          echo "date=${DATE}" >> "$GITHUB_OUTPUT"
          echo "branch=${BRANCH}" >> "$GITHUB_OUTPUT"

      - name: Prepare Docker tags
        id: docker-tags
        shell: bash
        run: |
          # Always include these tags
          TAGS="ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest"
          TAGS="$TAGS,ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.git-metadata.outputs.sha_short }}"
          TAGS="$TAGS,ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.git-metadata.outputs.date }}"

          # Add version tag if version was bumped (check if version exists and is not empty)
          if [ -n "${{ steps.bump.outputs.version }}" ]; then
            TAGS="$TAGS,ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.bump.outputs.version }}"
            echo "Version tag added: ${{ steps.bump.outputs.version }}"
          else
            echo "No version change detected, skipping version tag"
          fi

          echo "tags=${TAGS}" >> "$GITHUB_OUTPUT"
          echo "All tags: $TAGS"

      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: "temurin"
          java-version: "17"
          cache: "maven"

      - name: Static Code Analysis with SonarQube
        if: github.ref == 'refs/heads/master' # Only run on main branch
        run: |
          mvn verify sonar:sonar \
            -Dsonar.projectKey=${{ github.repository_owner }}_${{ env.IMAGE_NAME }} \
            -Dsonar.host.url=${{ secrets.SONAR_URL }} \
            -Dsonar.login=${{ secrets.SONAR_TOKEN }}

      - name: Build application
        run: mvn -B package --file pom.xml

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Install Cosign
        uses: sigstore/cosign-installer@main
        with:
          cosign-release: 'v2.2.0'

      - name: Build and Push Docker Image
        id: build-and-push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.docker-tags.outputs.tags }}
          provenance: true
          sbom: true

      - name: Sign the Docker Image with Cosign
        run: |
          # Extract version or use latest if not available
          VERSION="${{ steps.bump.outputs.version }}"
          if [ -z "$VERSION" ]; then
            VERSION="latest"
          fi
          
          # Sign the container image
          cosign sign --key env://COSIGN_PRIVATE_KEY ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${VERSION}
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
      
      - name: Output version for deployment job
        id: version-output
        run: |
          VERSION="${{ steps.bump.outputs.version }}"
          if [ -z "$VERSION" ]; then
            VERSION="latest"
          fi
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
    outputs:
      version: ${{ steps.version-output.outputs.version }}

  deploy:
    name: Verify and Deploy
    needs: build-and-deploy
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Install Cosign
        uses: sigstore/cosign-installer@main
        with:
          cosign-release: 'v2.2.0'
      
      - name: Install Trivy
        run: |
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | gpg --dearmor | sudo tee /usr/share/keyrings/trivy.gpg > /dev/null
          echo "deb [signed-by=/usr/share/keyrings/trivy.gpg] https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy
      
      - name: Verify Container Signature
        run: |
          cosign verify --key env://COSIGN_PUBLIC_KEY ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-deploy.outputs.version }}
        env:
          COSIGN_PUBLIC_KEY: ${{ secrets.COSIGN_PUBLIC_KEY }}
      
      - name: Scan Container Image for Vulnerabilities
        run: |
          trivy image --severity HIGH,CRITICAL --exit-code 1 ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-deploy.outputs.version }}
      
      - name: Deploy to Production
        run: |
          echo "Deploying verified container to production environment..."
          # Your deployment commands here
          # For example:
          # kubectl set image deployment/myapp myapp=ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-deploy.outputs.version }}
