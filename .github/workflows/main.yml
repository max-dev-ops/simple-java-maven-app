name: CI/CD Security Pipeline

on:
  push:
    branches: [master]
  workflow_dispatch: # Allow manual triggering

env:
  IMAGE_NAME: myapplication
  # IMPORTANT: Set your GHCR registry path
  REGISTRY: ghcr.io
  # IMPORTANT: Set your GitHub username or organization name
  GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}

jobs:
  # =========================================
  #        Build, Scan, Sign Job
  # =========================================
  build-scan-sign:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Read code, commit version bump
      packages: write # Push packages to GHCR
      id-token: write # Needed for Cosign keyless signing
      security-events: write # Needed to upload findings to GitHub Security tab (optional)

    outputs:
      image_tag: ${{ steps.docker-tags.outputs.sha_tag }} # Pass the specific tag to verify job
      image_digest: ${{ steps.build-push.outputs.digest }} # Pass the digest for potential verification

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Needed for Gitleaks history scan and versioning

      # --- Security Scan 1: Secret Scanning ---
      - name: Detect Secrets with Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # To upload findings
          # GITLEAKS_CONFIG: .gitleaks.toml # Uncomment if you have a config file

      # --- Optional: Cleanup (Adjust if needed) ---
      # Note: Careful if reports are generated outside target/
      - name: Cleanup workspace before build
        run: |
          echo "Cleaning up workspace..."
          git clean -fdx
          echo "Removing previous target dir..."
          rm -rf target/

      # --- Versioning ---
      - name: Bump Version
        id: bump
        uses: nnichols/maven-version-bump-action@v3

      - name: Print Version
        run: "echo 'New Version: ${{steps.bump.outputs.version}}'"

      # --- Git Metadata & Tags ---
      - name: Extract Git metadata for tagging
        id: git-metadata
        shell: bash
        run: |
          SHA_SHORT=$(git rev-parse --short HEAD)
          echo "sha_short=${SHA_SHORT}" >> "$GITHUB_OUTPUT"

      - name: Prepare Docker tags
        id: docker-tags
        shell: bash
        run: |
          SHA_TAG="${{ env.REGISTRY }}/${{ env.GITHUB_REPOSITORY_OWNER }}/${{ env.IMAGE_NAME }}:${{ steps.git-metadata.outputs.sha_short }}"
          LATEST_TAG="${{ env.REGISTRY }}/${{ env.GITHUB_REPOSITORY_OWNER }}/${{ env.IMAGE_NAME }}:latest"
          TAGS="$SHA_TAG,$LATEST_TAG" # Always include SHA and latest

          if [ -n "${{ steps.bump.outputs.version }}" ]; then
            VERSION_TAG="${{ env.REGISTRY }}/${{ env.GITHUB_REPOSITORY_OWNER }}/${{ env.IMAGE_NAME }}:${{ steps.bump.outputs.version }}"
            TAGS="$TAGS,$VERSION_TAG"
            echo "Version tag added: ${{ steps.bump.outputs.version }}"
          fi

          echo "tags=${TAGS}" >> "$GITHUB_OUTPUT"
          echo "sha_tag=${SHA_TAG}" >> "$GITHUB_OUTPUT" # Output specific tag for verification
          echo "All tags: $TAGS"

      # --- Setup Build Environment ---
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: "temurin"
          java-version: "17"
          cache: "maven"

      # --- Security Scans 2 & 3: Dependencies & SAST (via Maven) ---
      # NOTE: Assumes owasp-dependency-check-maven & spotbugs-maven-plugin configured in pom.xml
      - name: Run Maven Verify (includes Dep Check & SpotBugs)
        run: mvn -B verify --file pom.xml
        # This runs tests and plugins bound to the 'verify' phase.
        # Configure POM to fail build on critical findings if desired.

      # --- Build Application ---
      # Run package separately IF verify doesn't produce the needed artifact, otherwise verify might be enough
      - name: Build Application JAR
        run: mvn -B package -DskipTests --file pom.xml # Skip tests as they ran in 'verify'

      # --- Create Dockerfile ---
      - name: Create multi-stage Dockerfile
        run: |
          cat > Dockerfile << 'EOF'
          FROM maven:3.9-amazoncorretto-17 AS build
          WORKDIR /app
          COPY pom.xml .
          RUN mvn dependency:go-offline
          COPY src ./src
          # Using 'package' as 'verify' might not create the final JAR in target/ needed below
          RUN mvn clean package -DskipTests

          # Extract layers if Spring Boot, otherwise copy JAR
          RUN mkdir -p extracted && \
              if jar -tf target/*.jar | grep -q "BOOT-INF/layers.idx"; then \
                echo "Spring Boot layered JAR detected..."; \
                java -Djarmode=layertools -jar target/*.jar extract --destination extracted; \
              else \
                echo "Regular JAR detected..."; \
                mkdir -p extracted/application; \
                cp target/*.jar extracted/application/; \
              fi

          FROM eclipse-temurin:17-jre-alpine
          WORKDIR /app
          LABEL org.opencontainers.image.source=https://github.com/${{ github.repository }}
          RUN addgroup --system javauser && adduser --system --ingroup javauser javauser
          COPY --from=build --chown=javauser:javauser /app/extracted/ ./
          USER javauser
          ENV JAVA_OPTS="-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0"
          EXPOSE 8080
          ENTRYPOINT ["sh", "-c", "if [ -f 'org/springframework/boot/loader/JarLauncher.class' ]; then java $JAVA_OPTS org.springframework.boot.loader.JarLauncher; elif [ -d 'application' ]; then java $JAVA_OPTS -jar application/*.jar; else java $JAVA_OPTS -jar *.jar; fi"]
          EOF
      
      # --- Security Scan 4: Dockerfile Analysis with Trivy (MOVED BEFORE IMAGE BUILD) ---
      - name: Scan Dockerfile with Trivy
        uses: aquasecurity/trivy-action@0.17.0
        with:
          scan-type: 'config'
          scan-ref: './Dockerfile'
          format: 'table'  # Changed to table for better console output
          output: 'trivy-dockerfile-results.txt'
          exit-code: '1'  # Set to '1' to fail the workflow if issues are found
          severity: 'CRITICAL,HIGH'
          hide-progress: false
          # Limit checks to only Dockerfile-related policies
          policy-bundle: 'docker-basic'
          # Ignore policies not relevant to Dockerfiles
          skip-files: "*.rego"
          skip-dirs: "aws,kubernetes,cloud,devsecops,k8s"

      # --- Display Dockerfile scan results in console ---
      - name: Display Dockerfile Scan Results
        if: always()  # Run even if the previous step failed
        run: |
          echo "======= Dockerfile Scan Results ======="
          if [ -f "trivy-dockerfile-results.txt" ]; then
            cat trivy-dockerfile-results.txt
          else
            echo "No results file found"
          fi
          echo "======================================"

      # # --- Generate SARIF format for GitHub Security ---
      # - name: Scan Dockerfile with Trivy (SARIF format)
      #   uses: aquasecurity/trivy-action@0.17.0
      #   with:
      #     scan-type: 'config'
      #     scan-ref: './Dockerfile'
      #     format: 'sarif'
      #     output: 'trivy-dockerfile-results.sarif'
      #     exit-code: '1'
      #     severity: 'CRITICAL,HIGH'
      #     hide-progress: false
      #     # Limit checks to only Dockerfile-related policies
      #     policy-bundle: 'docker-basic'
      #     # Ignore policies not relevant to Dockerfiles
      #     skip-files: "*.rego"
      #     skip-dirs: "aws,kubernetes,cloud,devsecops,k8s"

      # --- Upload Dockerfile scan results to GitHub Security tab ---
      - name: Upload Trivy Dockerfile scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: success() || failure() # Always run this step to upload scan results
        with:
          sarif_file: trivy-dockerfile-results.sarif
          category: dockerfile-security
      
      # --- Build Container Image ---
      - name: Build Docker image
        id: build-docker
        uses: docker/build-push-action@v4
        with:
          context: .
          push: false # Build locally first for scanning
          load: true # Load image into docker daemon for Trivy scan
          tags: ${{ steps.docker-tags.outputs.tags }}

      # --- Push Container Image (Only if scans passed) ---
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push Docker image to GHCR
        id: build-push # Renamed from docker build-push step
        uses: docker/build-push-action@v4
        with:
          context: . # Context needs to be provided again for push digest output
          push: true
          tags: ${{ steps.docker-tags.outputs.tags }}
          # Ensure build args, etc., match the local build step if needed

      # --- Security Step 6: Sign Container Image ---
      - name: Install Cosign
        uses: sigstore/cosign-installer@main # Use specific version

      - name: Sign the container image with Cosign (Keyless)
        # This signs the manifest existing in the registry
        # Needs id-token: write permission for the job
        run: cosign sign --yes ${{ steps.docker-tags.outputs.sha_tag }}@${{ steps.build-push.outputs.digest }}
        env:
          # COSIGN_EXPERIMENTAL: 1 # Might be needed depending on cosign version for keyless
          # Rekor and Fulcio URLs default to public instances
          # Specify identity provider as GitHub Actions
          COSIGN_REPOSITORY: ${{ env.REGISTRY }}/${{ env.GITHUB_REPOSITORY_OWNER }}/${{ env.IMAGE_NAME }}

  # =========================================
  #        Verify Signature Job (Pseudo Deployment)
  # =========================================
  verify-signature:
    runs-on: ubuntu-latest
    needs: build-scan-sign # Run only after build-scan-sign succeeds

    steps:
      - name: Install Cosign
        uses: sigstore/cosign-installer@main # Use specific version

      - name: Verify container image signature (Pseudo Deployment Check)
        id: verify
        # Continue on error to print custom message
        continue-on-error: true
        run: |
          echo "Attempting to verify image: ${{ needs.build-scan-sign.outputs.image_tag }}"
          cosign verify \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            --certificate-identity-regexp "^https://github.com/${{ github.repository }}/.github/workflows/.*$" \
            ${{ needs.build-scan-sign.outputs.image_tag }}@${{ needs.build-scan-sign.outputs.image_digest }}
          # Adjust regexp if workflow path/name is different or for more strict matching
        env:
          COSIGN_REPOSITORY: ${{ env.REGISTRY }}/${{ env.GITHUB_REPOSITORY_OWNER }}/${{ env.IMAGE_NAME }}
          # COSIGN_EXPERIMENTAL: 1 # Might be needed

      - name: Print Verification Result
        run: |
          if [ ${{ steps.verify.outcome }} == 'success' ]; then
            echo "✅ Signature VERIFIED successfully for image ${{ needs.build-scan-sign.outputs.image_tag }}"
          else
            echo "❌ Signature verification FAILED for image ${{ needs.build-scan-sign.outputs.image_tag }}"
            # Optionally fail the workflow here if needed: exit 1
          fi
